{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"magic-di","text":"<p>Documentation: https://woltapp.github.io/magic-di</p> <p>Source Code: https://github.com/woltapp/magic-di</p> <p>PyPI: https://pypi.org/project/magic-di/</p> <p>Dependency Injector with minimal boilerplate code, built-in support for FastAPI and Celery, and seamless integration to basically anything.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Install</li> <li>Getting Started</li> <li>Clients Configuration</li> <li>Zero config clients</li> <li>Clients with Config</li> <li>Using interfaces instead of implementations</li> <li>Integration with Celery</li> <li>Function based tasks</li> <li>Class based tasks</li> <li>Custom integrations</li> <li>Manual injection</li> <li>Forced injections</li> <li>Healthcheck</li> <li>Testing</li> <li>Default simple mock</li> <li>Custom mocks</li> <li>Alternatives</li> <li>Development</li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install magic-di\n</code></pre> <p>With FastAPI integration:</p> <pre><code>pip install 'magic-di[fastapi]'\n</code></pre> <p>With Celery integration:</p> <pre><code>pip install 'magic-di[celery]'\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<pre><code>from fastapi import FastAPI\n\nfrom magic_di import Connectable\nfrom magic_di.fastapi import inject_app, Provide\n\napp = inject_app(FastAPI())\n\n\nclass Database:\n    connected: bool = False\n\n    def __connect__(self):\n        self.connected = True\n\n    def __disconnect__(self):\n        self.connected = False\n\n\nclass Service(Connectable):\n    def __init__(self, db: Database):\n        self.db = db\n\n    def is_connected(self):\n        return self.db.connected\n\n\n@app.get(path=\"/hello-world\")\ndef hello_world(service: Provide[Service]) -&gt; dict:\n    return {\n        \"is_connected\": service.is_connected()\n    }\n</code></pre> <p>That's all!</p> <p>This simple code will recursively inject all dependencies and connect them using the <code>__connect__</code> and <code>__disconnect__</code> magic methods.</p> <p>But what happened there? 1) We created a new FastAPI app and injected it. The <code>inject_app</code> function makes the injector connect all clients on app startup and disconnect them on shutdown. That\u2019s how you can open and close all connections (e.g., session to DB). 2) We defined new classes with <code>__connect__</code> and <code>__disconnect__</code> magic methods. That\u2019s how the injector finds classes that need to be injected. The injector uses duck typing to check if some class has these methods. It means you don\u2019t need to inherit from <code>ClientProtocol</code> (but you can to reduce the number of code lines). 3) Wrapped the <code>Service</code> type hint into <code>Provide</code> so that FastAPI can use our DI. Please note: you need to use <code>Provide</code> only in FastAPI endpoints, which makes your codebase independent from FastAPI and this Dependency Injector. 4) PROFIT!</p> <p>As you can see, in this example, you don\u2019t need to write special constructors to store your dependencies in global variables. All you need to do to complete the startup logic is to write it in the <code>__connect__</code> method.</p>"},{"location":"#clients-configuration","title":"Clients Configuration","text":"<p>This dependency injector promotes the idea of \u2018zero-config clients\u2019, but you can still use configurations if you prefer</p>"},{"location":"#zero-config-clients","title":"Zero config clients","text":"<p>Simply fetch everything needed from the environment. There is no need for an additional configuration file</p> <pre><code>from dataclasses import dataclass, field\n\nfrom pydantic import Field\nfrom pydantic_settings import BaseSettings\nfrom redis.asyncio import Redis as RedisClient, from_url\n\n\nclass RedisConfig(BaseSettings):\n    url: str = Field(validation_alias='REDIS_URL')\n    decode_responses: bool = Field(validation_alias='REDIS_DECODE_RESPONSES')\n\n\n@dataclass\nclass Redis:\n    config: RedisConfig = field(default_factory=RedisConfig)\n    client: RedisClient = field(init=False)\n\n    async def __connect__(self):\n        self.client = await from_url(self.config.url, decode_responses=self.config.decode_responses)\n        await self.client.ping()\n\n    async def __disconnect__(self):\n        await self.client.close()\n\n    @property\n    def db(self) -&gt; RedisClient:\n        return self.client\n\n\nRedis()  # works even without passing arguments in the constructor.\n</code></pre> <p>As an alternative, you can inject configs instead of using default factories.</p> <pre><code>from dataclasses import dataclass, field\n\nfrom pydantic import Field\nfrom pydantic_settings import BaseSettings\nfrom redis.asyncio import Redis as RedisClient, from_url\n\nfrom magic_di import Connectable, DependencyInjector\n\n\nclass RedisConfig(Connectable, BaseSettings):\n    url: str = Field(validation_alias='REDIS_URL')\n    decode_responses: bool = Field(validation_alias='REDIS_DECODE_RESPONSES')\n\n\n@dataclass\nclass Redis:\n    config: RedisConfig\n    client: RedisClient = field(init=False)\n\n    async def __connect__(self):\n        self.client = await from_url(self.config.url, decode_responses=self.config.decode_responses)\n        await self.client.ping()\n\n    async def __disconnect__(self):\n        await self.client.close()\n\n    @property\n    def db(self) -&gt; RedisClient:\n        return self.client\n\n\ninjector = DependencyInjector()\nredis = injector.inject(Redis)()  # works even without passing arguments in the constructor.\n\nasync with injector:\n    await redis.db.ping()\n</code></pre>"},{"location":"#using-interfaces-instead-of-implementations","title":"Using interfaces instead of implementations","text":"<p>Sometimes, you may not want to stick to a certain interface implementation everywhere. Therefore, you can use interfaces (protocols, abstract classes) with Dependency Injection (DI). With DI, you can effortlessly bind an implementation to an interface and subsequently update it if necessary.</p> <pre><code>from typing import Protocol\n\nfrom fastapi import FastAPI\n\nfrom magic_di import Connectable, DependencyInjector\nfrom magic_di.fastapi import inject_app, Provide\n\n\nclass MyInterface(Protocol):\n    def do_something(self) -&gt; bool:\n        ...\n\n\nclass MyInterfaceImplementation(Connectable):\n    def do_something(self) -&gt; bool:\n        return True\n\n\napp = inject_app(FastAPI())\n\ninjector = DependencyInjector()\ninjector.bind({MyInterface: MyInterfaceImplementation})\n\n\n@app.get(path=\"/hello-world\")\ndef hello_world(service: Provide[MyInterface]) -&gt; dict:\n    return {\n        \"result\": service.do_something(),\n    }\n</code></pre> <p>Using <code>injector.bind</code>, you can bind implementations that will be injected everywhere the bound interface is used.</p>"},{"location":"#integration-with-celery","title":"Integration with Celery","text":""},{"location":"#function-based-celery-tasks","title":"Function based celery tasks","text":"<pre><code>from celery import Celery\n\nfrom magic_di.celery import get_celery_loader, InjectableCeleryTask, PROVIDE\n\napp = Celery(\n    loader=get_celery_loader(),\n    task_cls=InjectableCeleryTask,\n)\n\n\n@app.task\nasync def calculate(x: int, y: int, calculator: Calculator = PROVIDE):\n    await calculator.calculate(x, y)\n</code></pre>"},{"location":"#class-based-celery-tasks","title":"Class based celery tasks","text":"<pre><code>from dataclasses import dataclass\n\nfrom celery import Celery\n\nfrom magic_di.celery import get_celery_loader, InjectableCeleryTask, BaseCeleryConnectableDeps, PROVIDE\n\napp = Celery(\n    loader=get_celery_loader(),\n    task_cls=InjectableCeleryTask,\n)\n\n\n@dataclass\nclass CalculatorTaskDeps(BaseCeleryConnectableDeps):\n    calculator: Calculator\n\n\nclass CalculatorTask(InjectableCeleryTask):\n    deps: CalculatorTaskDeps\n\n    async def run(self, x: int, y: int, smart_processor: SmartProcessor = PROVIDE):\n        return smart_processor.process(\n            await self.deps.calculator.calculate(x, y)\n        )\n\n\napp.register_task(CalculatorTask)\n</code></pre>"},{"location":"#limitations","title":"Limitations","text":"<p>You could notice that in these examples tasks are using Python async/await. <code>InjectableCeleryTask</code> provides support for writing async code. However, it still executes code synchronously. Due to this, getting results from async tasks is not possible in the following cases: * When the <code>task_always_eager</code> config flag is enabled and task creation occurs inside the running event loop (e.g., inside an async FastAPI endpoint) * When calling the <code>.apply()</code> method inside running event loop (e.g., inside an async FastAPI endpoint)</p>"},{"location":"#custom-integrations","title":"Custom integrations","text":"<p>For custom integration you can either use helper function <code>inject_and_run</code> or by using DependencyInjector manually</p> <pre><code>from magic_di.utils import inject_and_run\n\n\nasync def main(worker: Worker):\n    await worker.run()\n\nif __name__ == '__main__':\n    inject_and_run(main)\n</code></pre>"},{"location":"#manual-injection","title":"Manual injection","text":"<pre><code>import asyncio\n\nfrom magic_di import DependencyInjector\n\n\nasync def run_worker(worker: Worker):\n    await worker.run()\n\n\nasync def main():\n    injector = DependencyInjector()\n\n    injected_fn = injector.inject(run_worker)\n\n    async with injector:\n        await injected_fn()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"#forced-injections","title":"Forced injections","text":"<p>You can force injector to inject non-connectable dependencies with type hint annotation <code>Injectable</code></p> <pre><code>from typing import Annotated\n\nfrom magic_di import Injectable, Connectable\n\n\nclass Service(Connectable):\n    dependency: Annotated[NonConnectableDependency, Injectable]\n</code></pre>"},{"location":"#healthcheck","title":"Healthcheck","text":"<p>You can implement <code>Pingable</code> protocol to define healthchecks for your clients. The <code>DependenciesHealthcheck</code> will call the <code>__ping__</code> method on all injected clients that implement this protocol.</p> <pre><code>from magic_di.healthcheck import DependenciesHealthcheck\n\n\nclass Service(Connectable):\n    def __init__(self, db: Database):\n        self.db = db\n\n    def is_connected(self):\n        return self.db.connected\n\n    async def __ping__(self) -&gt; None:\n        if not self.is_connected():\n            raise Exception(\"Service is not connected\")\n\n\n@app.get(path=\"/hello-world\")\ndef hello_world(service: Provide[Service]) -&gt; dict:\n    return {\n        \"is_connected\": service.is_connected()\n    }\n\n\n@app.get(path=\"/healthcheck\")\nasync def healthcheck_handler(healthcheck: Provide[DependenciesHealthcheck]) -&gt; dict:\n    await healthcheck.ping_dependencies()\n    return {\"alive\": True}\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<p>If you need to mock a dependency in tests, you can easily do so by using the <code>injector.override</code> context manager and still use this dependency injector.</p> <p>To mock clients, you can use <code>InjectableMock</code> from the <code>testing</code> module.</p>"},{"location":"#default-simple-mock","title":"Default simple mock","text":"<pre><code>import pytest\nfrom fastapi.testclient import TestClient\nfrom my_app import app\n\nfrom magic_di import DependencyInjector\nfrom magic_di.testing import InjectableMock\n\n\n@pytest.fixture()\ndef injector():\n    return DependencyInjector()\n\n\n@pytest.fixture()\ndef service_mock() -&gt; Service:\n    return InjectableMock()\n\n\n@pytest.fixture()\ndef client(injector: DependencyInjector, service_mock: InjectableMock):\n    with injector.override({Service: service_mock.mock_cls}):\n        with TestClient(app) as client:\n            yield client\n\n\ndef test_http_handler(client):\n    resp = client.post('/hello-world')\n\n    assert resp.status_code == 200\n</code></pre>"},{"location":"#custom-mocks","title":"Custom mocks","text":"<p>As an alternative, you can your use custom mocks.</p> <pre><code>from magic_di.testing import get_injectable_mock_cls\n\n\n@pytest.fixture()\ndef service_mock() -&gt; Service:\n    return SomeSmartServiceMock()\n\n\n@pytest.fixture()\ndef client(injector: DependencyInjector, service_mock: Service):\n    with injector.override({Service: get_injectable_mock_cls(service_mock)}):\n        with TestClient(app) as client:\n            yield client\n</code></pre>"},{"location":"#alternatives","title":"Alternatives","text":""},{"location":"#fastapis-built-in-dependency-injection","title":"FastAPI's built-in dependency injection","text":"<p>FastAPI's built-in DI is great, but it makes the project (and its business logic) dependent on FastAPI, <code>fastapi.Depends</code> specifically.</p> <p><code>magic-di</code> decouples DI from other dependencies while still offering seamless integration to FastAPI, for example.</p>"},{"location":"#python-dependency-injector","title":"python-dependency-injector","text":"<p>python-dependency-injector is great, but it requires a notable amount of boilerplate code.</p> <p>The goal of <code>magic-di</code> is to reduce the amount of code as much as possible and get rid of enterprise code with countless configs, containers, and fabrics. The philosophy of <code>magic-di</code> is that clients know how to configure themselves and perform all startup routines.</p>"},{"location":"#development","title":"Development","text":"<ul> <li>Clone this repository</li> <li>Requirements:</li> <li>Poetry</li> <li>Python 3.10+</li> <li>Create a virtual environment and install the dependencies</li> </ul> <pre><code>poetry install --all-extras\n</code></pre> <ul> <li>Activate the virtual environment</li> </ul> <pre><code>poetry shell\n</code></pre>"},{"location":"#testing_1","title":"Testing","text":"<pre><code>pytest\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation is automatically generated from the content of the docs directory and from the docstrings  of the public signatures of the source code. The documentation is updated and published as a Github Pages page automatically as part each release.</p>"},{"location":"#releasing","title":"Releasing","text":"<p>Trigger the Draft release workflow (press Run workflow). This will update the changelog &amp; version and create a GitHub release which is in Draft state.</p> <p>Find the draft release from the GitHub releases and publish it. When  a release is published, it'll trigger release workflow which creates PyPI  release and deploys updated documentation.</p>"},{"location":"#pre-commit","title":"Pre-commit","text":"<p>Pre-commit hooks run all the auto-formatting (<code>ruff format</code>), linters (e.g. <code>ruff</code> and <code>mypy</code>), and other quality  checks to make sure the changeset is in good shape before a commit/push happens.</p> <p>You can install the hooks with (runs for each commit):</p> <pre><code>pre-commit install\n</code></pre> <p>Or if you want them to run only for each push:</p> <pre><code>pre-commit install -t pre-push\n</code></pre> <p>Or if you want e.g. want to run all checks manually for all files:</p> <pre><code>pre-commit run --all-files\n</code></pre> <p>This project was generated using the wolt-python-package-cookiecutter template.</p>"},{"location":"api_docs/","title":"API documentation","text":""},{"location":"api_docs/#magic_di.Connectable","title":"<code>Connectable</code>","text":"<p>You can inherit from this class to make the dependency visible for DI without adding these empty methods.</p> Source code in <code>src/magic_di/_connectable.py</code> <pre><code>class Connectable:\n    \"\"\"\n    You can inherit from this class to make the dependency visible for DI\n    without adding these empty methods.\n    \"\"\"\n\n    async def __connect__(self) -&gt; None: ...\n\n    async def __disconnect__(self) -&gt; None: ...\n</code></pre>"},{"location":"api_docs/#magic_di.ConnectableProtocol","title":"<code>ConnectableProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Interface for injectable clients. Adding these methods to your class will allow it to be dependency injectable. The dependency injector uses duck typing to check that the class implements the interface. This means that you do not need to inherit from this protocol.</p> Source code in <code>src/magic_di/_connectable.py</code> <pre><code>@runtime_checkable\nclass ConnectableProtocol(Protocol):\n    \"\"\"\n    Interface for injectable clients.\n    Adding these methods to your class will allow it to be dependency injectable.\n    The dependency injector uses duck typing to check that the class\n    implements the interface.\n    This means that you do not need to inherit from this protocol.\n    \"\"\"\n\n    async def __connect__(self) -&gt; None: ...\n\n    async def __disconnect__(self) -&gt; None: ...\n</code></pre>"},{"location":"api_docs/#magic_di.DependencyInjector","title":"<code>DependencyInjector</code>","text":"Source code in <code>src/magic_di/_injector.py</code> <pre><code>class DependencyInjector:\n    def __init__(\n        self,\n        bindings: dict[type, type] | None = None,\n        logger: logging.Logger = logger,\n    ):\n        self.bindings = bindings or {}\n        self.logger: logging.Logger = logger\n\n        self._deps = SingletonDependencyContainer()\n        self._postponed: list[Callable[..., T]] = []\n        self._lock = Lock()\n\n    def inject(self, obj: Callable[..., T]) -&gt; Callable[..., T]:\n        \"\"\"\n        Inject dependencies into a class/function.\n        This method is idempotent, always returns the same instance\n\n        Args:\n            obj (Callable[..., T]): The class/function to inject dependencies into.\n\n        Returns:\n            Callable[..., T]: Partial for class/function with dependencies injected.\n        \"\"\"\n        obj = self._unwrap_type_hint(obj)  # type: ignore[arg-type]\n\n        if dep := self._deps.get(obj):\n            return dep\n\n        signature = self.inspect(obj)\n\n        clients: dict[str, object] = {}\n        for name, dep in signature.deps.items():\n            clients[name] = self.inject(dep)()\n\n        if signature.injector_arg is not None:\n            clients[signature.injector_arg] = self\n\n        try:\n            return self._deps.add(obj, **clients)\n        except TypeError as exc:\n            raise InjectionError(obj, signature) from exc\n\n    def inspect(self, obj: AnyObject) -&gt; Signature[AnyObject]:\n        try:\n            hints: dict[str, type[Any]] = get_type_hints(obj)\n            hints_with_extras = get_type_hints(obj, include_extras=True)\n\n            if not hints:\n                return Signature(obj, is_injectable=bool(is_connectable(obj)))\n\n            if inspect.ismethod(obj):\n                hints.pop(\"self\", None)\n\n            hints.pop(\"return\", None)\n\n            signature = Signature(obj, is_injectable=bool(is_connectable(obj)))\n\n            for name, hint_ in hints.items():\n                hint = self._unwrap_type_hint(hint_)\n                hint_with_extra = hints_with_extras[name]\n\n                if is_injector(hint):\n                    signature.injector_arg = name\n                elif not is_connectable(hint) and not is_forcefully_marked_as_injectable(\n                    hint_with_extra,\n                ):\n                    signature.kwargs[name] = hint\n                else:\n                    signature.deps[name] = hint\n\n        except Exception as exc:\n            raise InspectionError(obj) from exc\n\n        return signature\n\n    async def connect(self) -&gt; None:\n        \"\"\"\n        Connect all injected dependencies\n        \"\"\"\n        # unpack to create copy of list\n        for postponed in [*self._postponed]:\n            # First, we need to create instances of postponed injection\n            # in order to connect them.\n            self.inject(postponed)\n\n        for cls, instance in self._deps.iter_instances():\n            if connectable_instance := is_connectable(instance):\n                self.logger.debug(\"Connecting %s...\", cls.__name__)\n                await connectable_instance.__connect__()\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"\n        Disconnect all injected dependencies\n        \"\"\"\n        for cls, instance in self._deps.iter_instances(reverse=True):\n            if connectable_instance := is_connectable(instance):\n                try:\n                    await connectable_instance.__disconnect__()\n                except Exception:\n                    self.logger.exception(\"Failed to disconnect %s\", cls.__name__)\n\n    def get_dependencies_by_interface(\n        self,\n        interface: Callable[..., AnyObject],\n    ) -&gt; Iterable[AnyObject]:\n        \"\"\"\n        Get all injected dependencies that implement a particular interface.\n        \"\"\"\n        for _, instance in self._deps.iter_instances():\n            if safe_is_instance(instance, interface):  # type: ignore[arg-type]\n                yield instance  # type: ignore[misc]\n\n    async def __aenter__(self) -&gt; DependencyInjector:  # noqa: PYI034\n        await self.connect()\n        return self\n\n    async def __aexit__(self, *args: object, **kwargs: Any) -&gt; None:\n        await self.disconnect()\n\n    def iter_deps(self) -&gt; Iterable[object]:\n        instance: object\n\n        for _, instance in self._deps.iter_instances():\n            yield instance\n\n    def lazy_inject(self, obj: Callable[..., T]) -&gt; Callable[..., T]:\n        \"\"\"\n        Lazily inject dependencies into a class or function.\n\n        Args:\n            obj (Callable[..., T]): The class or function to inject dependencies into.\n\n        Returns:\n            Callable[..., T]: A function that, when called,\n            will inject the dependencies and\n            return the injected class instance or function.\n        \"\"\"\n\n        with self._lock:\n            self._postponed.append(obj)  # type: ignore[arg-type]\n            # incompatible type \"Callable[..., T]\"; expected \"Callable[..., T]\"\n\n        injected: T | None = None\n\n        def inject() -&gt; T:\n            nonlocal injected\n\n            if injected is not None:\n                return injected\n\n            injected = self.inject(obj)()\n            return injected\n\n        return cast(type[T], inject)\n\n    def bind(self, bindings: dict[type, type]) -&gt; None:\n        \"\"\"\n        Bind new bindings to the injector.\n\n        This method is used to add new bindings to the injector.\n        Bindings are a dictionary where the keys are the\n        classes used in dependencies type hints,\n        and the values are the classes that should replace them.\n\n        For example, if you have a class `Foo` that depends on an interface `Bar`,\n        and you have a class `BarImpl` that implements `Bar`,\n        you would add a binding like this: `injector.bind({Bar: BarImpl})`.\n        Then, whenever `Foo` is injected,\n        it will receive an instance of `BarImpl` instead of `Bar`.\n\n        If a binding for a particular class or type already exists,\n        this method will update that binding with the new value\n\n        Args:\n            bindings (dict[type, type]): The bindings to add.\n            This should be a dictionary where the keys are\n            classes and the values are the classes that should replace them.\n        \"\"\"\n        with self._lock:\n            self.bindings = self.bindings | bindings\n\n    @contextmanager\n    def override(self, bindings: dict[type, type]) -&gt; Iterator[None]:\n        \"\"\"\n        Temporarily override the bindings and dependencies of the injector.\n\n        Args:\n            bindings (dict): The bindings to use for the override.\n        \"\"\"\n        with self._lock:\n            actual_deps = self._deps\n            actual_bindings = self.bindings\n\n            self._deps = SingletonDependencyContainer()\n            self.bindings = self.bindings | bindings\n\n        try:\n            yield\n        finally:\n            with self._lock:\n                self._deps = actual_deps\n                self.bindings = actual_bindings\n\n    def _unwrap_type_hint(self, obj: type[AnyObject]) -&gt; type[AnyObject]:\n        obj = get_cls_from_optional(obj)\n        return self.bindings.get(obj, obj)\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Injector is always unique\"\"\"\n        return id(self)\n</code></pre>"},{"location":"api_docs/#magic_di.DependencyInjector.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Injector is always unique</p> Source code in <code>src/magic_di/_injector.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Injector is always unique\"\"\"\n    return id(self)\n</code></pre>"},{"location":"api_docs/#magic_di.DependencyInjector.bind","title":"<code>bind(bindings: dict[type, type]) -&gt; None</code>","text":"<p>Bind new bindings to the injector.</p> <p>This method is used to add new bindings to the injector. Bindings are a dictionary where the keys are the classes used in dependencies type hints, and the values are the classes that should replace them.</p> <p>For example, if you have a class <code>Foo</code> that depends on an interface <code>Bar</code>, and you have a class <code>BarImpl</code> that implements <code>Bar</code>, you would add a binding like this: <code>injector.bind({Bar: BarImpl})</code>. Then, whenever <code>Foo</code> is injected, it will receive an instance of <code>BarImpl</code> instead of <code>Bar</code>.</p> <p>If a binding for a particular class or type already exists, this method will update that binding with the new value</p> <p>Parameters:</p> Name Type Description Default <code>bindings</code> <code>dict[type, type]</code> <p>The bindings to add.</p> required Source code in <code>src/magic_di/_injector.py</code> <pre><code>def bind(self, bindings: dict[type, type]) -&gt; None:\n    \"\"\"\n    Bind new bindings to the injector.\n\n    This method is used to add new bindings to the injector.\n    Bindings are a dictionary where the keys are the\n    classes used in dependencies type hints,\n    and the values are the classes that should replace them.\n\n    For example, if you have a class `Foo` that depends on an interface `Bar`,\n    and you have a class `BarImpl` that implements `Bar`,\n    you would add a binding like this: `injector.bind({Bar: BarImpl})`.\n    Then, whenever `Foo` is injected,\n    it will receive an instance of `BarImpl` instead of `Bar`.\n\n    If a binding for a particular class or type already exists,\n    this method will update that binding with the new value\n\n    Args:\n        bindings (dict[type, type]): The bindings to add.\n        This should be a dictionary where the keys are\n        classes and the values are the classes that should replace them.\n    \"\"\"\n    with self._lock:\n        self.bindings = self.bindings | bindings\n</code></pre>"},{"location":"api_docs/#magic_di.DependencyInjector.connect","title":"<code>connect() -&gt; None</code>  <code>async</code>","text":"<p>Connect all injected dependencies</p> Source code in <code>src/magic_di/_injector.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"\n    Connect all injected dependencies\n    \"\"\"\n    # unpack to create copy of list\n    for postponed in [*self._postponed]:\n        # First, we need to create instances of postponed injection\n        # in order to connect them.\n        self.inject(postponed)\n\n    for cls, instance in self._deps.iter_instances():\n        if connectable_instance := is_connectable(instance):\n            self.logger.debug(\"Connecting %s...\", cls.__name__)\n            await connectable_instance.__connect__()\n</code></pre>"},{"location":"api_docs/#magic_di.DependencyInjector.disconnect","title":"<code>disconnect() -&gt; None</code>  <code>async</code>","text":"<p>Disconnect all injected dependencies</p> Source code in <code>src/magic_di/_injector.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect all injected dependencies\n    \"\"\"\n    for cls, instance in self._deps.iter_instances(reverse=True):\n        if connectable_instance := is_connectable(instance):\n            try:\n                await connectable_instance.__disconnect__()\n            except Exception:\n                self.logger.exception(\"Failed to disconnect %s\", cls.__name__)\n</code></pre>"},{"location":"api_docs/#magic_di.DependencyInjector.get_dependencies_by_interface","title":"<code>get_dependencies_by_interface(interface: Callable[..., AnyObject]) -&gt; Iterable[AnyObject]</code>","text":"<p>Get all injected dependencies that implement a particular interface.</p> Source code in <code>src/magic_di/_injector.py</code> <pre><code>def get_dependencies_by_interface(\n    self,\n    interface: Callable[..., AnyObject],\n) -&gt; Iterable[AnyObject]:\n    \"\"\"\n    Get all injected dependencies that implement a particular interface.\n    \"\"\"\n    for _, instance in self._deps.iter_instances():\n        if safe_is_instance(instance, interface):  # type: ignore[arg-type]\n            yield instance  # type: ignore[misc]\n</code></pre>"},{"location":"api_docs/#magic_di.DependencyInjector.inject","title":"<code>inject(obj: Callable[..., T]) -&gt; Callable[..., T]</code>","text":"<p>Inject dependencies into a class/function. This method is idempotent, always returns the same instance</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Callable[..., T]</code> <p>The class/function to inject dependencies into.</p> required <p>Returns:</p> Type Description <code>Callable[..., T]</code> <p>Callable[..., T]: Partial for class/function with dependencies injected.</p> Source code in <code>src/magic_di/_injector.py</code> <pre><code>def inject(self, obj: Callable[..., T]) -&gt; Callable[..., T]:\n    \"\"\"\n    Inject dependencies into a class/function.\n    This method is idempotent, always returns the same instance\n\n    Args:\n        obj (Callable[..., T]): The class/function to inject dependencies into.\n\n    Returns:\n        Callable[..., T]: Partial for class/function with dependencies injected.\n    \"\"\"\n    obj = self._unwrap_type_hint(obj)  # type: ignore[arg-type]\n\n    if dep := self._deps.get(obj):\n        return dep\n\n    signature = self.inspect(obj)\n\n    clients: dict[str, object] = {}\n    for name, dep in signature.deps.items():\n        clients[name] = self.inject(dep)()\n\n    if signature.injector_arg is not None:\n        clients[signature.injector_arg] = self\n\n    try:\n        return self._deps.add(obj, **clients)\n    except TypeError as exc:\n        raise InjectionError(obj, signature) from exc\n</code></pre>"},{"location":"api_docs/#magic_di.DependencyInjector.lazy_inject","title":"<code>lazy_inject(obj: Callable[..., T]) -&gt; Callable[..., T]</code>","text":"<p>Lazily inject dependencies into a class or function.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Callable[..., T]</code> <p>The class or function to inject dependencies into.</p> required <p>Returns:</p> Type Description <code>Callable[..., T]</code> <p>Callable[..., T]: A function that, when called,</p> <code>Callable[..., T]</code> <p>will inject the dependencies and</p> <code>Callable[..., T]</code> <p>return the injected class instance or function.</p> Source code in <code>src/magic_di/_injector.py</code> <pre><code>def lazy_inject(self, obj: Callable[..., T]) -&gt; Callable[..., T]:\n    \"\"\"\n    Lazily inject dependencies into a class or function.\n\n    Args:\n        obj (Callable[..., T]): The class or function to inject dependencies into.\n\n    Returns:\n        Callable[..., T]: A function that, when called,\n        will inject the dependencies and\n        return the injected class instance or function.\n    \"\"\"\n\n    with self._lock:\n        self._postponed.append(obj)  # type: ignore[arg-type]\n        # incompatible type \"Callable[..., T]\"; expected \"Callable[..., T]\"\n\n    injected: T | None = None\n\n    def inject() -&gt; T:\n        nonlocal injected\n\n        if injected is not None:\n            return injected\n\n        injected = self.inject(obj)()\n        return injected\n\n    return cast(type[T], inject)\n</code></pre>"},{"location":"api_docs/#magic_di.DependencyInjector.override","title":"<code>override(bindings: dict[type, type]) -&gt; Iterator[None]</code>","text":"<p>Temporarily override the bindings and dependencies of the injector.</p> <p>Parameters:</p> Name Type Description Default <code>bindings</code> <code>dict</code> <p>The bindings to use for the override.</p> required Source code in <code>src/magic_di/_injector.py</code> <pre><code>@contextmanager\ndef override(self, bindings: dict[type, type]) -&gt; Iterator[None]:\n    \"\"\"\n    Temporarily override the bindings and dependencies of the injector.\n\n    Args:\n        bindings (dict): The bindings to use for the override.\n    \"\"\"\n    with self._lock:\n        actual_deps = self._deps\n        actual_bindings = self.bindings\n\n        self._deps = SingletonDependencyContainer()\n        self.bindings = self.bindings | bindings\n\n    try:\n        yield\n    finally:\n        with self._lock:\n            self._deps = actual_deps\n            self.bindings = actual_bindings\n</code></pre>"},{"location":"api_docs/#magic_di.celery","title":"<code>celery</code>","text":""},{"location":"api_docs/#magic_di.fastapi","title":"<code>fastapi</code>","text":"<p>Package containing tools for integrating Dependency Injector with FastAPI framework.</p>"},{"location":"api_docs/#magic_di.fastapi.inject_app","title":"<code>inject_app(app: FastAPI, *, injector: DependencyInjector | None = None, use_deprecated_events: bool = False) -&gt; FastAPI</code>","text":"<p>Inject dependencies into a FastAPI application using the provided injector.</p> <p>This function sets up the FastAPI application to connect and disconnect the injector at startup and shutdown, respectively.</p> <p>This ensures that all dependencies are properly connected when the application starts, and properly disconnected when the application shuts down.</p> <p>If no injector is provided, a default injector is used.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The FastAPI application</p> required <code>injector</code> <code>DependencyInjector</code> <p>The injector to use for dependency injection.                                      If not provided, a default injector will be used.</p> <code>None</code> <code>use_deprecated_events</code> <code>bool</code> <p>Indicate whether the app should be injected                                     with starlette events (which are deprecated)                                     or use app lifespans.                                     Important: Use this flag only                                     if you still use app events,                                     because if lifespans are defined,                                     events will be ignored by Starlette.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>FastAPI</code> <code>FastAPI</code> <p>The FastAPI application with dependencies injected.</p> Source code in <code>src/magic_di/fastapi/_app.py</code> <pre><code>def inject_app(\n    app: FastAPI,\n    *,\n    injector: DependencyInjector | None = None,\n    use_deprecated_events: bool = False,\n) -&gt; FastAPI:\n    \"\"\"\n    Inject dependencies into a FastAPI application using the provided injector.\n\n    This function sets up the FastAPI application to connect and disconnect the injector\n    at startup and shutdown, respectively.\n\n    This ensures that all dependencies are properly\n    connected when the application starts, and properly disconnected when the application\n    shuts down.\n\n    If no injector is provided, a default injector is used.\n\n    Args:\n        app (FastAPI): The FastAPI application\n\n        injector (DependencyInjector, optional): The injector to use for dependency injection.\n                                                 If not provided, a default injector will be used.\n\n        use_deprecated_events (bool, optional): Indicate whether the app should be injected\n                                                with starlette events (which are deprecated)\n                                                or use app lifespans.\n                                                Important: Use this flag only\n                                                if you still use app events,\n                                                because if lifespans are defined,\n                                                events will be ignored by Starlette.\n\n    Returns:\n        FastAPI: The FastAPI application with dependencies injected.\n    \"\"\"\n    injector = injector or DependencyInjector()\n\n    def collect_deps() -&gt; None:\n        _collect_dependencies(injector, app.router)\n\n    app.state.dependency_injector = injector\n\n    if use_deprecated_events:\n        _inject_app_with_events(app, collect_deps_fn=collect_deps)\n    else:\n        _inject_app_with_lifespan(app, collect_deps_fn=collect_deps)\n\n    return app\n</code></pre>"},{"location":"api_docs/#magic_di.healthcheck","title":"<code>healthcheck</code>","text":""},{"location":"api_docs/#magic_di.healthcheck.DependenciesHealthcheck","title":"<code>DependenciesHealthcheck</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Connectable</code></p> <p>Injectable Healthcheck component that pings all injected dependencies that implement the PingableProtocol</p> <p>Example usage:</p> <pre><code>from app.components.services.health import DependenciesHealthcheck\n\nasync def main(redis: Redis, deps_healthcheck: DependenciesHealthcheck) -&gt; None:\n    await deps_healthcheck.ping_dependencies()  # redis will be pinged if it has method __ping__\n\ninject_and_run(main)\n</code></pre> Source code in <code>src/magic_di/healthcheck.py</code> <pre><code>@dataclass\nclass DependenciesHealthcheck(Connectable):\n    \"\"\"\n    Injectable Healthcheck component that pings all injected dependencies\n    that implement the PingableProtocol\n\n    Example usage:\n\n    ``` py\n    from app.components.services.health import DependenciesHealthcheck\n\n    async def main(redis: Redis, deps_healthcheck: DependenciesHealthcheck) -&gt; None:\n        await deps_healthcheck.ping_dependencies()  # redis will be pinged if it has method __ping__\n\n    inject_and_run(main)\n    ```\n    \"\"\"\n\n    injector: DependencyInjector\n\n    async def ping_dependencies(self, max_concurrency: int = 1) -&gt; None:\n        \"\"\"\n        Ping all dependencies that implement the PingableProtocol\n\n        :param max_concurrency: Maximum number of concurrent pings\n        \"\"\"\n        tasks: set[Future[Any]] = set()\n\n        try:\n            for dependency in self.injector.get_dependencies_by_interface(PingableProtocol):\n                future = asyncio.ensure_future(self.ping(dependency))\n                tasks.add(future)\n\n                if len(tasks) &gt;= max_concurrency:\n                    tasks, _ = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n\n            if tasks:\n                await asyncio.gather(*tasks)\n                tasks = set()\n\n        finally:\n            for task in tasks:\n                task.cancel()\n\n            if tasks:\n                with suppress(asyncio.CancelledError):\n                    await asyncio.gather(*tasks)\n\n    async def ping(self, dependency: PingableProtocol) -&gt; None:\n        \"\"\"\n        Ping a single dependency\n\n        :param dependency: Dependency to ping\n        \"\"\"\n        dependency_name = dependency.__class__.__name__\n        self.injector.logger.debug(\"Pinging dependency %s...\", dependency_name)\n\n        await dependency.__ping__()\n\n        self.injector.logger.debug(\"Dependency %s is healthy\", dependency_name)\n</code></pre>"},{"location":"api_docs/#magic_di.healthcheck.DependenciesHealthcheck.ping","title":"<code>ping(dependency: PingableProtocol) -&gt; None</code>  <code>async</code>","text":"<p>Ping a single dependency</p> <p>:param dependency: Dependency to ping</p> Source code in <code>src/magic_di/healthcheck.py</code> <pre><code>async def ping(self, dependency: PingableProtocol) -&gt; None:\n    \"\"\"\n    Ping a single dependency\n\n    :param dependency: Dependency to ping\n    \"\"\"\n    dependency_name = dependency.__class__.__name__\n    self.injector.logger.debug(\"Pinging dependency %s...\", dependency_name)\n\n    await dependency.__ping__()\n\n    self.injector.logger.debug(\"Dependency %s is healthy\", dependency_name)\n</code></pre>"},{"location":"api_docs/#magic_di.healthcheck.DependenciesHealthcheck.ping_dependencies","title":"<code>ping_dependencies(max_concurrency: int = 1) -&gt; None</code>  <code>async</code>","text":"<p>Ping all dependencies that implement the PingableProtocol</p> <p>:param max_concurrency: Maximum number of concurrent pings</p> Source code in <code>src/magic_di/healthcheck.py</code> <pre><code>async def ping_dependencies(self, max_concurrency: int = 1) -&gt; None:\n    \"\"\"\n    Ping all dependencies that implement the PingableProtocol\n\n    :param max_concurrency: Maximum number of concurrent pings\n    \"\"\"\n    tasks: set[Future[Any]] = set()\n\n    try:\n        for dependency in self.injector.get_dependencies_by_interface(PingableProtocol):\n            future = asyncio.ensure_future(self.ping(dependency))\n            tasks.add(future)\n\n            if len(tasks) &gt;= max_concurrency:\n                tasks, _ = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n\n        if tasks:\n            await asyncio.gather(*tasks)\n            tasks = set()\n\n    finally:\n        for task in tasks:\n            task.cancel()\n\n        if tasks:\n            with suppress(asyncio.CancelledError):\n                await asyncio.gather(*tasks)\n</code></pre>"},{"location":"api_docs/#magic_di.testing","title":"<code>testing</code>","text":""},{"location":"api_docs/#magic_di.testing.InjectableMock","title":"<code>InjectableMock</code>","text":"<p>               Bases: <code>AsyncMock</code></p> <p>You can use this mock to override dependencies in tests and use AsyncMock instead of a real class instance</p> <p>Example:</p> <pre><code>@pytest.fixture()\ndef client():\n  injector = DependencyInjector()\n\n  with injector.override({Service: InjectableMock().mock_cls}):\n    with TestClient(app) as client:\n        yield client\n\ndef test_http_handler(client):\n  resp = client.post('/hello-world')\n\n  assert resp.status_code == 200\n</code></pre> Source code in <code>src/magic_di/testing.py</code> <pre><code>class InjectableMock(AsyncMock):\n    \"\"\"\n    You can use this mock to override dependencies in tests\n    and use AsyncMock instead of a real class instance\n\n    Example:\n    ``` py\n    @pytest.fixture()\n    def client():\n      injector = DependencyInjector()\n\n      with injector.override({Service: InjectableMock().mock_cls}):\n        with TestClient(app) as client:\n            yield client\n\n    def test_http_handler(client):\n      resp = client.post('/hello-world')\n\n      assert resp.status_code == 200\n    ```\n    \"\"\"\n\n    @property\n    def mock_cls(self) -&gt; type[ConnectableProtocol]:\n        return get_injectable_mock_cls(self)\n\n    async def __connect__(self) -&gt; None: ...\n\n    async def __disconnect__(self) -&gt; None: ...\n\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; InjectableMock:\n        return self.__class__(*args, **kwargs)\n</code></pre>"},{"location":"api_docs/#magic_di.utils","title":"<code>utils</code>","text":""},{"location":"api_docs/#magic_di.utils.inject_and_run","title":"<code>inject_and_run(fn: Callable[..., T], injector: DependencyInjector | None = None) -&gt; T</code>","text":"<p>This function takes a callable, injects dependencies into it using the provided injector, and then runs the function. If the function is a coroutine, it will be awaited.</p> <p>The function itself is not asynchronous, but it uses asyncio.run to run the internal coroutine, so it is suitable for use in synchronous code.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable</code> <p>The function into which dependencies will be injected. This can be            a regular function or a coroutine function.</p> required <code>injector</code> <code>DependencyInjector</code> <p>The injector to use for dependency injection.                                      If not provided, a default injector will be used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>T</code> <p>The return value of the function <code>fn</code> after dependency injection and execution.</p> Source code in <code>src/magic_di/utils.py</code> <pre><code>def inject_and_run(\n    fn: Callable[..., T],\n    injector: DependencyInjector | None = None,\n) -&gt; T:\n    \"\"\"\n    This function takes a callable, injects dependencies into it using the provided injector,\n    and then runs the function. If the function is a coroutine, it will be awaited.\n\n    The function itself is not asynchronous, but it uses asyncio.run\n    to run the internal coroutine, so it is suitable for use in synchronous code.\n\n    Args:\n        fn (Callable): The function into which dependencies will be injected. This can be\n                       a regular function or a coroutine function.\n        injector (DependencyInjector, optional): The injector to use for dependency injection.\n                                                 If not provided, a default injector will be used.\n\n    Returns:\n        Any: The return value of the function `fn` after dependency injection and execution.\n\n    Raises:\n        Any exceptions raised by the function `fn` or the injector will be propagated up to\n        the caller of this function.\n    \"\"\"\n    injector = injector or DependencyInjector()\n\n    async def run() -&gt; T:\n        injected = injector.inject(fn)\n\n        async with injector:\n            if inspect.iscoroutinefunction(fn):\n                return await injected()  # type: ignore[misc,no-any-return]\n\n            return injected()\n\n    return asyncio.run(run())\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#030-2024-11-13","title":"0.3.0 - 2024-11-13","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Compatibility with PyCharm for FastAPI <code>Provide</code> type hints</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Removed <code>Provider</code> class</li> </ul>"},{"location":"changelog/#021-2024-10-01","title":"0.2.1 - 2024-10-01","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed compatibility with Python3.10 for optional type hints</li> </ul>"},{"location":"changelog/#020-2024-09-27","title":"0.2.0 - 2024-09-27","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Added <code>magic_di.healthcheck.DependenciesHealthcheck</code> class to make health checks of injected dependencies that implement <code>magic_di.healthcheck.PingableProtocol</code> interface</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Inject dependencies inside of event loop in <code>magic_di.utils.inject_and_run</code> to prevent wrong event loop usage inside of the injected dependencies</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Cruft update to get changes from the cookiecutter template</li> <li>Renamed LICENCE -&gt; LICENSE, now it's automatically included in the wheel created by poetry</li> </ul>"},{"location":"changelog/#010-2024-03-28","title":"0.1.0 - 2024-03-28","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Initial version</li> </ul>"}]}